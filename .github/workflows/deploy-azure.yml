name: Deploy Memgraph on AKS

on:
  push:
    branches: [ dev ]
  workflow_dispatch:

permissions:
  id-token: write   # OIDC login
  contents: read

env:
  # Azure authentication
  ARM_SUBSCRIPTION_ID:  ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID:        ${{ secrets.AZURE_TENANT_ID }}
  ARM_CLIENT_ID:        ${{ secrets.AZURE_CLIENT_ID }}

  # Stack parameters
  ENVIRONMENT:   dev
  NODE_VM_SIZE:  Standard_B2ms        # change here if you need a bigger node
  TF_DIR: infra/azure

jobs:
  deploy:
    runs-on: ubuntu-latest
    defaults: { run: { shell: bash } }

    steps:
    #─────────────────────────── repo ───────────────────────────
    - uses: actions/checkout@v4

    #────────────────────── Azure login (OIDC) ──────────────────
    - name: Azure login
      uses: azure/login@v2
      with:
        client-id:        ${{ env.ARM_CLIENT_ID }}
        tenant-id:        ${{ env.ARM_TENANT_ID }}
        subscription-id:  ${{ env.ARM_SUBSCRIPTION_ID }}
        auth-type: SERVICE_PRINCIPAL
        audience: api://AzureADTokenExchange

    #────────────────────── Terraform ─────────────────────────
    - uses: hashicorp/setup-terraform@v2

    - name: Terraform init
      env: { TF_IN_AUTOMATION: true }
      run: terraform -chdir=$TF_DIR init -input=false -no-color

    # TRY TO IMPORT ALL PRE-EXISTING RESOURCES  ───────────────────
    - name: Import pre-existing resources (generic)
      env:
        TF_IN_AUTOMATION: true
        RG_NAME:  rg-aks-memgraph-${{ env.ENVIRONMENT }}
        AKS_NAME: aks-memgraph-${{ env.ENVIRONMENT }}
      run: |
        set -euo pipefail
        echo "::group::Import resources"

        # 1) Always import the resource-group if it exists
        if az group exists --name "$RG_NAME" | grep -q true; then
          terraform -chdir="$TF_DIR" import -no-color -input=false -lock=false \
            azurerm_resource_group.this \
            "/subscriptions/${ARM_SUBSCRIPTION_ID}/resourceGroups/${RG_NAME}" \
            || true
        else
          echo "RG $RG_NAME not found – will be created"
        fi

        # 2) Generic map for everything else
        declare -A IMPORT_MAP

        # ── AKS cluster
        IMPORT_MAP[azurerm_kubernetes_cluster.this]="\/subscriptions/${ARM_SUBSCRIPTION_ID}/resourceGroups/${RG_NAME}/providers/Microsoft.ContainerService/managedClusters/${AKS_NAME}"

        # ── ADD FUTURE RESOURCES HERE -----------------------------------
        # Example for a Key Vault called kv-ai-agent:
        # IMPORT_MAP[azurerm_key_vault.this]="\
        # /subscriptions/${ARM_SUBSCRIPTION_ID}/resourceGroups/${RG_NAME}/providers/Microsoft.KeyVault/vaults/kv-ai-agent"

        for TF_ADDR in "${!IMPORT_MAP[@]}"; do
          AZ_ID="${IMPORT_MAP[$TF_ADDR]}"
          echo "Attempting import: $TF_ADDR → $AZ_ID"
          terraform -chdir="$TF_DIR" import -no-color -input=false -lock=false \
            "$TF_ADDR" "$AZ_ID" || echo "Import skipped/not found"
        done

        echo "::endgroup::"

    - name: Terraform apply
      env: { TF_IN_AUTOMATION: true }
      run: |
        terraform -chdir=$TF_DIR apply -auto-approve -input=false -no-color \
          -var="subscription_id=${{ env.ARM_SUBSCRIPTION_ID }}" \
          -var="location=germanywestcentral" \
          -var="environment=${{ env.ENVIRONMENT }}" \
          -var="node_vm_size=${{ env.NODE_VM_SIZE }}"


    #─────────────────── Get AKS kubeconfig ─────────────────────
    - name: Pull cluster credentials
      run: |
        az aks get-credentials \
          --resource-group rg-aks-memgraph-${{ env.ENVIRONMENT }} \
          --name          aks-memgraph-${{ env.ENVIRONMENT }} \
          --overwrite-existing

    #────────────────── Build / store credentials ──────────────
    - name: Build credentials hash
      id: hash
      run: |
        echo "value=$(echo -n '${{ secrets.MEMGRAPH_USERNAME }}${{ secrets.MEMGRAPH_PASSWORD }}' \
              | sha256sum | cut -d' ' -f1)" >> "$GITHUB_OUTPUT"

    - name: Create / update K8s secret
      env:
        MEMGRAPH_USERNAME: ${{ secrets.MEMGRAPH_USERNAME }}
        MEMGRAPH_PASSWORD: ${{ secrets.MEMGRAPH_PASSWORD }}
      run: |
        kubectl create secret generic memgraph-credentials \
          --from-literal=username="$MEMGRAPH_USERNAME" \
          --from-literal=password="$MEMGRAPH_PASSWORD" \
          --dry-run=client -o yaml | kubectl apply -f -

    #──────────────────── Apply Kubernetes YAML ─────────────────
    - name: Apply StorageClass
      run: kubectl apply -f infra/k8s/storageclass.yaml

    - name: Apply Memgraph manifest
      env:
        CREDENTIALS_HASH:  ${{ steps.hash.outputs.value }}
        ENVIRONMENT:       ${{ env.ENVIRONMENT }}
      run: envsubst < infra/k8s/memgraph.yaml | kubectl apply -f -

    #──────────────────────── Smoke test ────────────────────────
    - name: Wait for rollout (with diagnostics)
      run: |
        set -e
        if kubectl rollout status deployment/memgraph --timeout=10m ; then
          echo "Memgraph deployment ready ✓"
        else
          echo "::warning::Rollout timed out – printing diagnostics"
          kubectl get pods -o wide
          kubectl describe deployment memgraph || true
          POD=$(kubectl get pods -l app=memgraph -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
          if [ -n "$POD" ]; then
            kubectl describe pod "$POD" || true
            kubectl logs "$POD" --all-containers --tail=100 || true
          fi
          exit 1
        fi
