name: Deploy to Azure

on:
  push:
    branches: [ dev ]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  ENVIRONMENT: dev
  AZURE_RESOURCE_GROUP: GitHub
  AZURE_LOCATION: germanywestcentral
  MEMGRAPH_URI_TEMPLATE: memgraph-aiagent-{env}.{location}.cloudapp.azure.com

jobs:
  deploy-infrastructure:
    runs-on: ubuntu-latest
    timeout-minutes: 30  # Add timeout to prevent infinite runs
    steps:
      - uses: actions/checkout@v3
          
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          allow-no-subscriptions: false
          audience: api://AzureADTokenExchange
          auth-type: SERVICE_PRINCIPAL
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
      
      - name: Terraform Init
        run: |
          cd infra/azure
          terraform init
      
      - name: Import Existing Resources
        run: |
          cd infra/azure
          ENVIRONMENT=${{ env.ENVIRONMENT }} \
          SUBSCRIPTION_ID=${{ secrets.AZURE_SUBSCRIPTION_ID }} \
          TENANT_ID=${{ secrets.AZURE_TENANT_ID }} \
          OBJECT_ID=${{ secrets.AZURE_SP_OBJECT_ID }} \
          CI_MODE=true \
          ./import_resources.sh

      - name: Terraform Plan
        run: |
          cd infra/azure
          terraform plan -var="environment=${{ env.ENVIRONMENT }}" \
            -var="memgraph_username=${{ secrets.MEMGRAPH_USERNAME }}" \
            -var="memgraph_password=${{ secrets.MEMGRAPH_PASSWORD }}" \
            -var="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
            -var="tenant_id=${{ secrets.AZURE_TENANT_ID }}" \
            -var="object_id=${{ secrets.AZURE_SP_OBJECT_ID }}"
      
      - name: Terraform Apply
        run: |
          cd infra/azure
          terraform apply -auto-approve \
            -var="environment=${{ env.ENVIRONMENT }}" \
            -var="memgraph_username=${{ secrets.MEMGRAPH_USERNAME }}" \
            -var="memgraph_password=${{ secrets.MEMGRAPH_PASSWORD }}" \
            -var="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
            -var="tenant_id=${{ secrets.AZURE_TENANT_ID }}" \
            -var="object_id=${{ secrets.AZURE_SP_OBJECT_ID }}"
      
      - name: Get AKS Credentials
        run: |
          # Wait for the AKS cluster to be ready
          echo "Waiting for AKS cluster to be ready..."
          for i in {1..30}; do
            if az aks show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
                --name aks-ai-agent-${{ env.ENVIRONMENT }} --query "provisioningState" -o tsv | grep -q "Succeeded"; then
              echo "AKS cluster is ready"
              break
            fi
            echo "Waiting for AKS cluster to be ready (attempt $i)..."
            sleep 10
          done
          
          # Get credentials
          az aks get-credentials --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name aks-ai-agent-${{ env.ENVIRONMENT }}
      
      - name: Create K8s Secret for Memgraph
        run: |
          # Check if kubectl is working and the cluster is accessible
          if ! kubectl get nodes &>/dev/null; then
            echo "Cannot connect to Kubernetes cluster. Waiting for it to become available..."
            for i in {1..10}; do
              sleep 15
              if kubectl get nodes &>/dev/null; then
                echo "Successfully connected to Kubernetes cluster"
                break
              fi
              echo "Attempt $i: Still waiting for Kubernetes cluster..."
              if [ $i -eq 10 ]; then
                echo "Failed to connect to Kubernetes cluster after multiple attempts. Continuing anyway..."
              fi
            done
          fi
          
          # Create a credentials hash to force pod restart when credentials change using maximum security approach
          # Create a random file name to prevent predictable access
          TEMP_FILE=$(mktemp)
          
          # Write credentials directly to file descriptor to prevent command line visibility
          {
            printf "%s" "${{ secrets.MEMGRAPH_USERNAME }}"
            printf "%s" "${{ secrets.MEMGRAPH_PASSWORD }}"
          } > "$TEMP_FILE"
          
          # Generate hash and immediately remove the file
          CREDENTIALS_HASH=$(sha256sum "$TEMP_FILE" | awk '{print $1}')
          rm -f "$TEMP_FILE"
          
          # Store hash in environment variable for later use
          echo "CREDENTIALS_HASH=$CREDENTIALS_HASH" >> $GITHUB_ENV
          
          # Apply the kubernetes secret with the new credentials
          kubectl create secret generic memgraph-credentials \
            --from-literal=username=${{ secrets.MEMGRAPH_USERNAME }} \
            --from-literal=password=${{ secrets.MEMGRAPH_PASSWORD }} \
            --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Deploy to AKS
        run: |
          # Replace the placeholder with the actual credentials hash
          cat infra/k8s/memgraph.yaml | CREDENTIALS_HASH=${CREDENTIALS_HASH} envsubst > memgraph_deploy.yaml
          
          # Apply the updated deployment manifest
          kubectl apply -f memgraph_deploy.yaml
          
          # Force restart if the deployment already exists
          POD_NAME=$(kubectl get pods -l app=memgraph -o jsonpath="{.items[0].metadata.name}" 2>/dev/null || echo "")
          if [[ -n "$POD_NAME" ]]; then
            echo "Forcing restart of existing Memgraph pod..."
            kubectl delete pod $POD_NAME
          fi
          
          # Remove the temporary file
          rm memgraph_deploy.yaml
      
      - name: Verify Deployment
        run: |
          echo "Checking deployment status..."
          kubectl get pods
          kubectl get services
          
          echo "Waiting for Memgraph pod to be ready (may take up to 10 minutes)..."
          # First, check if there are any existing failed pods and delete them
          FAILED_PODS=$(kubectl get pods -l app=memgraph -o jsonpath="{.items[?(@.status.phase=='Failed' || @.status.containerStatuses[0].state.waiting.reason=='CrashLoopBackOff')].metadata.name}")
          if [[ -n "$FAILED_PODS" ]]; then
            echo "Found failed pods, cleaning up before proceeding:"
            echo "$FAILED_PODS" | tr ' ' '\n' | while read pod; do
              echo "Deleting failed pod: $pod"
              kubectl delete pod $pod
            done
            echo "Waiting for cleanup to complete..."
            sleep 30
          fi
          
          # Wait for pod to be ready with increased timeout and check interval
          if ! kubectl wait --for=condition=ready pod -l app=memgraph --timeout=10m; then
            echo "Error: Memgraph pod did not become ready within the timeout period."
            echo "Checking Memgraph pod logs:"
            POD_NAME=$(kubectl get pods -l app=memgraph -o jsonpath="{.items[0].metadata.name}")
            
            echo "Pod details:"
            kubectl describe pod $POD_NAME
            
            echo "Pod logs:"
            kubectl logs $POD_NAME --tail=100
            
            echo "Checking node resource utilization:"
            kubectl describe nodes
            
            echo "Deployment verification failed! Please check the Kubernetes cluster's resources and capacity."
            exit 1
          fi
          
          echo "Memgraph deployment successful!"
          
          # Wait for the LoadBalancer service to get an external IP
          echo "Waiting for LoadBalancer to get external IP..."
          for i in {1..45}; do
            EXTERNAL_IP=$(kubectl get service memgraph -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [[ -n "$EXTERNAL_IP" ]]; then
              echo "Memgraph is accessible at: ${EXTERNAL_IP}:7687"
              
              # Add a simple connectivity check
              echo "Performing basic connectivity test..."
              if nc -z -w 5 ${EXTERNAL_IP} 7687; then
                echo "Successfully connected to Memgraph on port 7687!"
              else
                echo "Warning: Could not connect to Memgraph on port 7687. The service may not be fully ready yet."
              fi
              break
            fi
            echo "Waiting for external IP (attempt $i)..."
            sleep 10
          done
          
          if [[ -z "$EXTERNAL_IP" ]]; then
            echo "Warning: Could not obtain external IP for Memgraph service within timeout."
            echo "Checking LoadBalancer service status:"
            kubectl describe service memgraph
          fi