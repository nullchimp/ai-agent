# .github/workflows/deploy-memgraph-aks.yml
name: Deploy Memgraph on AKS

on:
  push:
    branches: [ dev ]
  workflow_dispatch:

permissions:
  id-token: write          # OIDC login
  contents:  read

env:
  ############################################################
  # Azure authentication (set these three as repo secrets)
  ############################################################
  ARM_SUBSCRIPTION_ID:  ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID:        ${{ secrets.AZURE_TENANT_ID }}
  ARM_CLIENT_ID:        ${{ secrets.AZURE_CLIENT_ID }}

  DB_USERNAME:        ${{ secrets.MEMGRAPH_USERNAME }}
  DB_PASSWORD:        ${{ secrets.MEMGRAPH_PASSWORD }}

  ############################################################
  # Stack parameters - COST OPTIMIZED
  ############################################################
  ENVIRONMENT:  dev
  LOCATION: germanywestcentral
  NODE_VM_SIZE: Standard_B2s     # Minimal cost VM size meeting AKS requirements (2 vCPUs, 4GB RAM)

  ############################################################
  # Location of your *.tf files (change only this line
  # if you move Terraform to another folder)
  ############################################################
  TF_DIR: infra/azure
  RESOURCE_GROUP: "ai-agent"
  AKS_NAME: aks-memgraph

jobs:
  deploy:
    runs-on: ubuntu-latest
    defaults: { run: { shell: bash } }

    steps:
    #‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ repo ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - uses: actions/checkout@v4

    #‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Azure login (OIDC) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - name: Azure login
      uses: azure/login@v2
      with:
        client-id:        ${{ env.ARM_CLIENT_ID }}
        tenant-id:        ${{ env.ARM_TENANT_ID }}
        subscription-id:  ${{ env.ARM_SUBSCRIPTION_ID }}
        auth-type: SERVICE_PRINCIPAL
        audience: api://AzureADTokenExchange

    #‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Terraform init ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - uses: hashicorp/setup-terraform@v2

    - name: Terraform init
      env: { TF_IN_AUTOMATION: true }
      run: |
        terraform -chdir="$TF_DIR" init -input=false -no-color

    #‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Import EVERY pre-existing resource ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - name: Import Azure resources already present
      env: { TF_IN_AUTOMATION: true }
      run: |
        set -euo pipefail
        echo "::group::terraform import"

        RG_NAME="${{env.RESOURCE_GROUP}}-${{ env.ENVIRONMENT }}"
        AKS_NAME="${{env.AKS_NAME}}-${{ env.ENVIRONMENT }}"

        ### 1) Resource-group (special-case test) ###############
        if az group exists --name "$RG_NAME" | grep -q true; then
          terraform -chdir="$TF_DIR" import -no-color -input=false \
            -var="subscription_id=${{ env.ARM_SUBSCRIPTION_ID }}" \
            -var="location=${{env.LOCATION}}" \
            -var="resource_group=${{ env.RESOURCE_GROUP }}-${{ env.ENVIRONMENT }}" \
            -var="environment=${{ env.ENVIRONMENT }}" \
            -var="node_vm_size=${{ env.NODE_VM_SIZE }}" \
            azurerm_resource_group.this \
            "/subscriptions/${ARM_SUBSCRIPTION_ID}/resourceGroups/${RG_NAME}"
        else
          echo "RG $RG_NAME will be created by Terraform."
        fi

        ### 2) Generic map ‚Äì add new rows when you add resources
        declare -A MAP

        # AKS cluster
        MAP[azurerm_kubernetes_cluster.this]="/subscriptions/${ARM_SUBSCRIPTION_ID}/resourceGroups/${RG_NAME}/providers/Microsoft.ContainerService/managedClusters/${AKS_NAME}"

        # ‚îÄ‚îÄ Example for future resources (uncomment / adapt) ‚îÄ‚îÄ
        # MAP[azurerm_key_vault.this]="\
        # /subscriptions/${ARM_SUBSCRIPTION_ID}/resourceGroups/${RG_NAME}/providers/Microsoft.KeyVault/vaults/kv-ai-agent"
        # MAP[azurerm_container_registry.this]="\
        # /subscriptions/${ARM_SUBSCRIPTION_ID}/resourceGroups/${RG_NAME}/providers/Microsoft.ContainerRegistry/registries/craiagentreg"

        ### Attempt imports; skip if object truly absent ########
        for TF_ADDR in "${!MAP[@]}"; do
          AZ_ID="${MAP[$TF_ADDR]}"
          if az resource show --ids "$AZ_ID" --query "id" -o tsv &>/dev/null; then
            echo "Importing $TF_ADDR"
            terraform -chdir="$TF_DIR" import -no-color -input=false \
              -var="subscription_id=${{ env.ARM_SUBSCRIPTION_ID }}" \
              -var="location=${{env.LOCATION}}" \
              -var="resource_group=${{ env.RESOURCE_GROUP }}-${{ env.ENVIRONMENT }}" \
              -var="environment=${{ env.ENVIRONMENT }}" \
              -var="node_vm_size=${{ env.NODE_VM_SIZE }}" \
              "$TF_ADDR" "$AZ_ID"
          else
            echo "Azure object not found ‚Üí $AZ_ID (skipping)"
          fi
        done

        echo "::endgroup::"

    #‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Terraform apply ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - name: Terraform apply
      env: { TF_IN_AUTOMATION: true }
      run: |
        terraform -chdir="$TF_DIR" apply -auto-approve -input=false -no-color \
          -var="subscription_id=${{ env.ARM_SUBSCRIPTION_ID }}" \
          -var="location=${{ env.LOCATION }}" \
          -var="resource_group=${{ env.RESOURCE_GROUP }}" \
          -var="environment=${{ env.ENVIRONMENT }}" \
          -var="node_vm_size=${{ env.NODE_VM_SIZE }}"

    #‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Get AKS kubeconfig (always) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - name: Pull cluster credentials
      run: |
        az aks get-credentials \
          --resource-group "${{ env.RESOURCE_GROUP }}-${{ env.ENVIRONMENT }}" \
          --name "${{ env.AKS_NAME }}-${{ env.ENVIRONMENT }}" \
          --overwrite-existing

    #‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Secret (username / password) in K8s ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - name: Build credentials hash
      id: hash
      run: |
        echo "value=$(echo -n '${{ env.DB_USERNAME }}${{ env.DB_PASSWORD }}' | sha256sum | cut -d' ' -f1)" >> "$GITHUB_OUTPUT"

    - name: Create or update memgraph-credentials secret
      env:
        MEMGRAPH_USERNAME: ${{ env.DB_USERNAME }}
        MEMGRAPH_PASSWORD: ${{ env.DB_PASSWORD }}
      run: |
        # Validate credentials are not empty
        if [ -z "$MEMGRAPH_USERNAME" ] || [ -z "$MEMGRAPH_PASSWORD" ]; then
          echo "‚ùå ERROR: MEMGRAPH_USERNAME and MEMGRAPH_PASSWORD must not be empty"
          exit 1
        fi
        
        # Validate password strength (minimum 8 characters)
        if [ ${#MEMGRAPH_PASSWORD} -lt 8 ]; then
          echo "‚ùå ERROR: MEMGRAPH_PASSWORD must be at least 8 characters long"
          exit 1
        fi
        
        echo "‚úÖ Credentials validation passed"
        
        kubectl create secret generic memgraph-credentials \
          --from-literal=username="$MEMGRAPH_USERNAME" \
          --from-literal=password="$MEMGRAPH_PASSWORD" \
          --dry-run=client -o yaml | kubectl apply -f -
          
        echo "‚úÖ Memgraph credentials secret updated"

    #‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ StorageClass & Kubernetes manifests ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - name: Apply StorageClass (Standard SSD)
      run: kubectl apply -f infra/k8s/storageclass.yaml

    - name: Apply Memgraph Deployment & Service
      env:
        CREDENTIALS_HASH: ${{ steps.hash.outputs.value }}
        ENVIRONMENT:      ${{ env.ENVIRONMENT }}
      run: |
        # Force restart with simplified approach
        echo "Applying Memgraph configuration..."
        envsubst < infra/k8s/memgraph.yaml | kubectl apply -f -
        
        # Simple restart to ensure new credentials are loaded
        kubectl rollout restart deployment/memgraph
        kubectl rollout status deployment/memgraph --timeout=300s
        ./scripts/force_restart_memgraph.sh || echo "Restart completed with non-zero exit code, continuing anyway"
        
        # Wait for deployment to be ready
        echo "Waiting for Memgraph deployment to be ready..."
        kubectl wait --for=condition=available deployment/memgraph --timeout=10m
        
        # Wait for pod to be ready
        echo "Waiting for Memgraph pod to be ready..."
        kubectl wait --for=condition=ready pod -l app=memgraph --timeout=10m
        
        # Display deployment status
        echo "‚úÖ Deployment completed successfully!"
        echo "Current Memgraph pod status:"
        kubectl get pods -l app=memgraph -o wide
        
        echo "Current Memgraph service status:"
        kubectl get service memgraph -o wide
        
        # Get external IP for connection
        echo "üåê External access information:"
        EXTERNAL_IP=$(kubectl get service memgraph -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        if [ -n "$EXTERNAL_IP" ]; then
          echo "Memgraph is accessible at:"
          echo "  Bolt Protocol: $EXTERNAL_IP:7687"
          echo "  HTTP API: $EXTERNAL_IP:7444"
          echo "  Memgraph Lab UI: $EXTERNAL_IP:3000"
          echo "  Username: ${{ env.DB_USERNAME }}"
          echo "  Password: [PROTECTED]"
        else
          echo "‚è≥ LoadBalancer IP assignment pending - check Azure portal"
        fi

    #‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Validate Connection & Authentication ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    - name: Set up Python environment for validation
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'

    - name: Install Python dependencies for validation
      run: |
        python -m venv .venv-validation
        source .venv-validation/bin/activate
        pip install --upgrade pip
        pip install pymgclient python-dotenv

    - name: Validate Memgraph connection and authentication
      env:
        DB_USERNAME: ${{ env.DB_USERNAME }}
        DB_PASSWORD: ${{ env.DB_PASSWORD }}
      run: |
        source .venv-validation/bin/activate
        
        # Wait for LoadBalancer IP to be assigned (up to 10 minutes)
        echo "‚è≥ Waiting for LoadBalancer IP assignment..."
        for i in {1..60}; do
          EXTERNAL_IP=$(kubectl get service memgraph -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          if [ -n "$EXTERNAL_IP" ] && [ "$EXTERNAL_IP" != "null" ]; then
            echo "‚úÖ LoadBalancer IP assigned: $EXTERNAL_IP"
            break
          fi
          echo "  Attempt $i/60: Waiting for IP assignment..."
          sleep 10
        done
        
        if [ -z "$EXTERNAL_IP" ] || [ "$EXTERNAL_IP" = "null" ]; then
          echo "‚ùå LoadBalancer IP not assigned after 10 minutes"
          echo "üîç Service status:"
          kubectl describe service memgraph
          exit 1
        fi
        
        # Set environment variable for the validation script
        export MEMGRAPH_HOST="$EXTERNAL_IP"
        
        # Run comprehensive validation
        echo "üöÄ Running Memgraph deployment validation..."
        python scripts/validate_memgraph_deployment.py
        
        echo "‚úÖ Memgraph deployment validation completed successfully!"
        echo "üåê Memgraph is accessible at:"
        echo "  Bolt Protocol: $EXTERNAL_IP:7687"
        echo "  HTTP API: $EXTERNAL_IP:7444"
        echo "  Memgraph Lab UI: $EXTERNAL_IP:3000"
